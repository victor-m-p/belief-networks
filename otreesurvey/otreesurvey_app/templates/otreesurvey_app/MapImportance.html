{% extends "global/Page.html" %}

{% block content %}
<h2>Adjust Importance of Beliefs</h2>
<p>You can now resize the circles to indicate importance. <strong>Larger circles represent items that are more important to your personal meat eating behavior</strong>. You do so by hovering over the edge of the circles, clicking and then dragging. You can make the circles both smaller or larger. You can still reposition and connect them as before.</p>

<canvas id="dragCanvas" width="900" height="600" style="border:1px solid black;"></canvas>

<div id="edgeSelectionPanel" style="display:none; position: absolute; left: 620px; top: 100px; background: #f9f9f9; border: 1px solid #ccc; padding: 20px;">
    <p style="font-weight: bold; margin-bottom: 10px;">Choose edge type:</p>
    <button id="selectPositive" type="button" style="background-color: green; color: white; padding: 10px 20px;">Positive</button>
    <button id="selectNegative" type="button" style="background-color: red; color: white; padding: 10px 20px;">Negative</button>
</div>

<input type="hidden" id="positions_5" name="positions_5">
<input type="hidden" id="edges_5" name="edges_5">

{{ formfield_errors 'positions_5' }}
{{ formfield_errors 'edges_5' }}
{{ next_button }}

<script>
const beliefLabels = {{ belief_labels_json|safe }};
const beliefPoints = {{ belief_points|safe }};
const beliefEdges = {{ belief_edges|safe }};

document.addEventListener("DOMContentLoaded", function () {
    const canvas = document.getElementById("dragCanvas");
    const ctx = canvas.getContext("2d");
    const resizeMargin = 4;

    const points = [
        { label: "Meat Eating", x: canvas.width/2, y: canvas.height/2, radius: 20, fixed: true },
        ...beliefPoints.map(p => ({ label: p.label, x: p.x, y: p.y, radius: p.radius }))
    ];

    let edges = beliefEdges.map(e => {
        const from = points.find(p => p.label === e.from);
        const to = points.find(p => p.label === e.to);
        return { from, to, polarity: e.polarity, strength: e.strength };
    }).filter(e => e.from && e.to);

    let draggingPoint = null;
    let resizingPoint = null;
    let selectedPoint = null;
    let hoveredPoint = null;
    let wasDragging = false;
    let pendingEdge = null;

    function drawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);

        edges.forEach(edge => {
            ctx.beginPath();
            ctx.moveTo(edge.from.x, edge.from.y);
            ctx.lineTo(edge.to.x, edge.to.y);
            ctx.strokeStyle = edge.polarity === "positive" ? "green" : "red";
            ctx.lineWidth = 1 + (edge.strength / 100) * 9;
            ctx.stroke();
        });

        points.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI);
            ctx.fillStyle = p === selectedPoint ? "yellow" : "orange";
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = "black";
            ctx.font = "14px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText(p.label, p.x, p.y - 22);
        });
    }

    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    function findPoint(pos) {
        return points.find(p => Math.hypot(p.x - pos.x, p.y - pos.y) <= p.radius + 4);
    }

    canvas.addEventListener("mousedown", function (evt) {
        const pos = getMousePos(evt);
        const hit = findPoint(pos);
        if (hit) {
            const dist = Math.hypot(hit.x - pos.x, hit.y - pos.y);
            if (dist > hit.radius - resizeMargin && dist <= hit.radius + resizeMargin) {
                resizingPoint = hit;
            } else {
                draggingPoint = hit;
            }
        }
        wasDragging = false;
    });

    canvas.addEventListener("mousemove", function (evt) {
        const pos = getMousePos(evt);
        hoveredPoint = findPoint(pos);

        if (draggingPoint) {
            draggingPoint.x = pos.x;
            draggingPoint.y = pos.y;
            wasDragging = true;
        }

        if (resizingPoint) {
            const dx = pos.x - resizingPoint.x;
            const dy = pos.y - resizingPoint.y;
            resizingPoint.radius = Math.max(8, Math.min(80, Math.hypot(dx, dy)));
            wasDragging = true;
        }

        drawCanvas();
    });

    canvas.addEventListener("mouseup", function (evt) {
        const pos = getMousePos(evt);
        const hit = findPoint(pos);

        if (!wasDragging && hit) {
            if (!selectedPoint) {
                selectedPoint = hit;
            } else if (selectedPoint !== hit) {
                const exists = edges.find(e =>
                    (e.from === selectedPoint && e.to === hit) || (e.from === hit && e.to === selectedPoint));
                if (exists) {
                    edges.splice(edges.indexOf(exists), 1);
                } else {
                    pendingEdge = { from: selectedPoint, to: hit };
                    document.getElementById("edgeSelectionPanel").style.display = "block";
                }
                selectedPoint = null;
            } else {
                selectedPoint = null;
            }
        }
        draggingPoint = null;
        resizingPoint = null;
    });

    document.getElementById("selectPositive").addEventListener("click", function () {
        if (pendingEdge) {
            pendingEdge.polarity = "positive";
            pendingEdge.strength = 50;
            edges.push(pendingEdge);
            pendingEdge = null;
            document.getElementById("edgeSelectionPanel").style.display = "none";
            drawCanvas();
        }
    });

    document.getElementById("selectNegative").addEventListener("click", function () {
        if (pendingEdge) {
            pendingEdge.polarity = "negative";
            pendingEdge.strength = 50;
            edges.push(pendingEdge);
            pendingEdge = null;
            document.getElementById("edgeSelectionPanel").style.display = "none";
            drawCanvas();
        }
    });

    document.querySelector("button[type=submit], .otree-btn-next").addEventListener("click", function (e) {
        e.preventDefault();

        const allInside = points.every(p => p.x >= 0 && p.x <= 900 && p.y >= 0 && p.y <= 600);
        const anyResized = points.some(p => p.radius !== 20);

        if (!allInside) {
            alert("Please drag all beliefs into the square before continuing.");
            return;
        }

        if (!anyResized) {
            alert("Please resize at least one belief to indicate importance.");
            return;
        }

        document.getElementById("positions_5").value = JSON.stringify(points.map(p => ({
            label: p.label,
            x: p.x,
            y: p.y,
            radius: p.radius
        })));

        document.getElementById("edges_5").value = JSON.stringify(edges.map(e => ({
            from: e.from.label,
            to: e.to.label,
            polarity: e.polarity,
            strength: e.strength
        })));

        document.querySelector("form").submit();
    });

    drawCanvas();
});
</script>
{% endblock %}
