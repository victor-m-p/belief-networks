{% extends "global/Page.html" %}
{% block styles %}
<style>
    #node-container {
        margin-bottom: 20px;
        text-align: center;
    }

    .belief-node {
        display: inline-block;
        padding: 10px 20px;
        background-color: orange;
        color: black;
        border-radius: 20px;
        font-weight: bold;
        font-size: 18px;
        user-select: none;
        cursor: grab;
    }

    canvas {
        border: 2px solid black;
    }
</style>
{% endblock %}

{% block content %}
<h2>Move Each Statement Into the Box</h2>

<p><strong>Your task is to place motivations and habits close to each other that influence each other more.</strong></p>

<ol>
    <li>Drag the first motivation or habit into the box.</li>
    <li>Position it relative to your meat eating habits. If it is very important to your personal meat eating frequency, place it close to the grey dot.</li>
    <li>A new motivation or habit will now appear.</li>
    <li>Continue to position new motivations or habits according to both your personal meat eating frequency (grey dot) and according to the things you have already placed.</li>
</ol>

<p>You can move all of the circles throughout.</p>

<p><em>Remember to think of the distance like: "if one of these things changed how much would it affect the other thing".</em></p>

<div id="node-container">
    <div id="current-node" class="belief-node" draggable="true"></div>
</div>

<canvas id="dragCanvas" width="900" height="600"></canvas>

<input type="hidden" name="positions_1" id="positions_1">
{{ next_button }}

<!-- JSON data safely passed to JS -->
<script>
    const beliefLabels = {{ belief_labels_json|safe }};
</script>

<script>
document.addEventListener("DOMContentLoaded", function () {
    let currentIndex = 0;
    const canvas = document.getElementById("dragCanvas");
    const ctx = canvas.getContext("2d");
    let pointsOnCanvas = [];

    const centralNode = { label: "Meat Eating", x: canvas.width/2, y: canvas.height/2, fixed: true };
    pointsOnCanvas.push(centralNode);

    let draggingPoint = null;
    let offsetX, offsetY;

    function showNextNode() {
        const nodeDiv = document.getElementById("current-node");
        if (currentIndex < beliefLabels.length) {
            const label = beliefLabels[currentIndex];
            nodeDiv.innerHTML = label.replace(/\n/g, '<br>');
            nodeDiv.dataset.originalLabel = label;
            nodeDiv.style.visibility = "visible";
        } else {
            nodeDiv.style.visibility = "hidden";
        }
    }

    showNextNode();

    document.getElementById("current-node").addEventListener("dragstart", function (e) {
        e.dataTransfer.setData("text/plain", e.target.dataset.originalLabel);
    });

    canvas.addEventListener("dragover", function (e) {
        e.preventDefault();
    });

    canvas.addEventListener("drop", function (e) {
        e.preventDefault();
        const label = e.dataTransfer.getData("text/plain");
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (!pointsOnCanvas.find(p => p.label === label)) {
            pointsOnCanvas.push({ label, x, y });
            currentIndex++;
            showNextNode();
            drawCanvas();
        }
    });

    function drawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);

        pointsOnCanvas.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 20, 0, Math.PI * 2);
            ctx.fillStyle = p.fixed ? "#999999" : "orange";
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.stroke();

            ctx.fillStyle = "black";
            ctx.font = "14px sans-serif";
            ctx.textAlign = "center";

            const lines = p.label.split('\n');
            const lineHeight = 16;
            const baseY = p.y - 28;

            lines.forEach((line, index) => {
                const y = baseY - (lines.length - index - 1) * lineHeight
                ctx.fillText(line, p.x, y);
            });
        });
    }

    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    function findPoint(pos) {
        return pointsOnCanvas.find(p => 
            Math.hypot(p.x - pos.x, p.y - pos.y) <= 20 && !p.fixed
        );
    }

    canvas.addEventListener("mousedown", function (e) {
        const pos = getMousePos(e);
        draggingPoint = findPoint(pos);
        if (draggingPoint) {
            offsetX = pos.x - draggingPoint.x;
            offsetY = pos.y - draggingPoint.y;
        }
    });

    canvas.addEventListener("mousemove", function (e) {
        if (draggingPoint) {
            const pos = getMousePos(e);
            draggingPoint.x = pos.x - offsetX;
            draggingPoint.y = pos.y - offsetY;
            drawCanvas();
        }
    });

    canvas.addEventListener("mouseup", function () {
        draggingPoint = null;
    });

    function allPointsInsideBox() {
        return pointsOnCanvas.every(p => p.x >= 0 && p.x <= canvas.width && p.y >= 0 && p.y <= canvas.height);
    }

    const form = document.querySelector("form");
    const nextButton = document.querySelector("button[type=submit], .otree-btn-next");

    nextButton.addEventListener("click", function (e) {
        e.preventDefault();

        if (pointsOnCanvas.length - 1 !== beliefLabels.length) {
            alert("Please place all beliefs into the square before continuing.");
            return;
        }

        if (!allPointsInsideBox()) {
            alert("Please place all beliefs inside the box before continuing.");
            return;
        }

        document.getElementById("positions_1").value = JSON.stringify(pointsOnCanvas);
        form.submit();
    });

    drawCanvas();
});
</script>
{% endblock %}
