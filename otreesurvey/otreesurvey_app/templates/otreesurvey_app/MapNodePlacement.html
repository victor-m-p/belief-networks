{% extends "global/Page.html" %}
{% block styles %}
<style>
    #node-container {
        margin-bottom: 20px;
        text-align: center;
    }

    .belief-node {
        display: inline-block;
        padding: 10px 20px;
        background-color: orange;
        color: black;
        border-radius: 20px;
        font-weight: bold;
        font-size: 18px;
        user-select: none;
        cursor: grab;
    }

    canvas {
        border: 2px solid black;
    }
</style>
{% endblock %}

{% block content %}
<h2>Drag each <span style="color: orange;">summary statement</span> into the box</h2>

<p><strong>Position things that influence each other more closer to each other</strong>. Place <span style="color: orange;">orange circles</span> closer to the <span style="color: grey;">central grey "Meat Eating" circle</span> if they have more influence on your meat eating frequency. Position <span style="color: orange;">orange circles</span> closer to each other if they influence each other more.</p>

<button type="button" id="toggle-instructions" style="
    background-color: #007BFF;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
    margin-bottom: 1rem;">
    Show Instructions
</button>

<!-- Instruction Box (initially hidden) -->
<div id="instruction-container" style="display: none; margin-bottom: 1rem; border: 1px solid #ccc; padding: 1rem; border-radius: 5px; background-color: #f9f9f9;">
    <ol>
        <li>Drag the first item into the box</li>
        <li>Position it relative to your meat eating frequency. If it is very important to your meat eating frequency place it close to the grey circle</li>
        <li>A new item will now appear above the box</li>
        <li>Continue to position new items based on how they influence your meat eating frequency and how the items influence each other</li>
    </ol>
    <p>You can continue to move all of the orange circles throughout this phase.</p>
</div>


<div id="node-container">
    <div id="current-node" class="belief-node" draggable="true"></div>
</div>

<canvas id="dragCanvas" width="900" height="600"></canvas>

<input type="hidden" name="positions_1" id="positions_1">
{{ next_button }}

<!-- JSON data safely passed to JS -->
<script>
    const beliefLabels = {{ belief_labels_json|safe }};
</script>

<script>
document.addEventListener("DOMContentLoaded", function () {

    // Toggle instruction box
    const toggleBtn = document.getElementById("toggle-instructions");
    const instructionBox = document.getElementById("instruction-container");

    toggleBtn.addEventListener("click", function () {
        const isHidden = instructionBox.style.display === "none" || instructionBox.style.display === "";
        instructionBox.style.display = isHidden ? "block" : "none";
        toggleBtn.textContent = isHidden ? "Hide Instructions" : "Show Instructions";
    });

    let currentIndex = 0;
    const canvas = document.getElementById("dragCanvas");
    const ctx = canvas.getContext("2d");
    let pointsOnCanvas = [];

    const centralNode = { label: "Meat Eating", x: canvas.width/2, y: canvas.height/2, fixed: true };
    pointsOnCanvas.push(centralNode);

    let draggingPoint = null;
    let offsetX, offsetY;

    function showNextNode() {
        const nodeDiv = document.getElementById("current-node");
        if (currentIndex < beliefLabels.length) {
            const label = beliefLabels[currentIndex];
            nodeDiv.innerHTML = label.replace(/\n/g, '<br>');
            nodeDiv.dataset.originalLabel = label;
            nodeDiv.style.visibility = "visible";
        } else {
            nodeDiv.style.visibility = "hidden";
        }
    }

    showNextNode();

    document.getElementById("current-node").addEventListener("dragstart", function (e) {
        e.dataTransfer.setData("text/plain", e.target.dataset.originalLabel);
    });

    canvas.addEventListener("dragover", function (e) {
        e.preventDefault();
    });

    canvas.addEventListener("drop", function (e) {
        e.preventDefault();
        const label = e.dataTransfer.getData("text/plain");
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (!pointsOnCanvas.find(p => p.label === label)) {
            pointsOnCanvas.push({ label, x, y });
            currentIndex++;
            showNextNode();
            drawCanvas();
        }
    });

    function drawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);

        pointsOnCanvas.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 20, 0, Math.PI * 2);
            ctx.fillStyle = p.fixed ? "#999999" : "orange";
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.stroke();

            ctx.fillStyle = "black";
            ctx.font = "14px sans-serif";
            ctx.textAlign = "center";

            const lines = p.label.split('\n');
            const lineHeight = 16;
            const baseY = p.y - 28;

            lines.forEach((line, index) => {
                const y = baseY - (lines.length - index - 1) * lineHeight
                ctx.fillText(line, p.x, y);
            });
        });
    }

    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    function findPoint(pos) {
        return pointsOnCanvas.find(p => 
            Math.hypot(p.x - pos.x, p.y - pos.y) <= 20 && !p.fixed
        );
    }

    canvas.addEventListener("mousedown", function (e) {
        const pos = getMousePos(e);
        draggingPoint = findPoint(pos);
        if (draggingPoint) {
            offsetX = pos.x - draggingPoint.x;
            offsetY = pos.y - draggingPoint.y;
        }
    });

    canvas.addEventListener("mousemove", function (e) {
        if (draggingPoint) {
            const pos = getMousePos(e);
            draggingPoint.x = pos.x - offsetX;
            draggingPoint.y = pos.y - offsetY;
            drawCanvas();
        }
    });

    canvas.addEventListener("mouseup", function () {
        draggingPoint = null;
    });

    function allPointsInsideBox() {
        return pointsOnCanvas.every(p => p.x >= 0 && p.x <= canvas.width && p.y >= 0 && p.y <= canvas.height);
    }

    const form = document.querySelector("form");
    const nextButton = document.querySelector("button[type=submit], .otree-btn-next");

    nextButton.addEventListener("click", function (e) {
        e.preventDefault();

        if (pointsOnCanvas.length - 1 !== beliefLabels.length) {
            alert("Please place all beliefs into the square before continuing.");
            return;
        }

        if (!allPointsInsideBox()) {
            alert("Please place all beliefs inside the box before continuing.");
            return;
        }

        document.getElementById("positions_1").value = JSON.stringify(pointsOnCanvas);
        form.submit();
    });

    drawCanvas();
});
</script>
{% endblock %}
